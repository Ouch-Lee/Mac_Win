# 预测模型node

## AR + MA



自回归模型的基本形式可以表示为：

$$
X_t = c + \phi_1 X_{t-1} + \phi_2 X_{t-2} + \ldots + \phi_p X_{t-p} + \varepsilon_t
$$



  - **$X_t$**：当前时刻的观测值。
  - **$c$**：常数项（可选）。
  - **$\phi_1, \phi_2, \ldots, \phi_p$**：模型参数，表示自回归系数。
  - **$p$**：模型的阶数，表示使用多少个过去的值进行预测。
  - **$\varepsilon_t$**：白噪声（误差项），通常假设为独立同分布的随机变量

就是根据前面的数据进行建模然后拟合一个多项式，然后预测下一个时刻的点。

作为预测模型最简单的例子，该模型只具备预测的功能，只能通过对震颤进行建模然后进行预测

* 关于AR与信号平稳性之间的关系

  似乎没有关系，对于稳定信号，比如白噪声，AR的效果非常的不好；而非平稳信号，比如正弦叠加一次函数，反而可以精准的预测；

  另外实验数据中出现的扰动是1hz左右的平稳信号

1. MA 模型的定义

一个MA模型可以表示为 MA(q)，其中 \(q\) 是模型的阶数。其数学表达式为：

$$
X_t = \mu + \epsilon_t + \theta_1 \epsilon_{t-1} + \theta_2 \epsilon_{t-2} + \cdots + \theta_q \epsilon_{t-q}
$$

其中：
- \(X_t\) 是时间序列的当前值。
- \(\mu\) 是时间序列的均值（常数项）。
- \(\epsilon_t\) 是白噪声（随机误差项），假设其服从均值为 0、方差为 \(\sigma^2\) 的正态分布。
- \(\theta_1, \theta_2, \dots, \theta_q\) 是模型的参数，表示过去误差项对当前值的影响。

---

2. MA 模型的核心思想

- 当前时刻 \(X_t\) 的值不仅取决于当前的噪声 \(\epsilon_t\)，还受前 \(q\) 个时刻噪声 \(\epsilon_{t-1}, \epsilon_{t-2}, \dots, \epsilon_{t-q}\) 的影响。
- 参数 \(\theta_i\) 控制了每个滞后误差对 \(X_t\) 的贡献强度。
- 由于 MA 模型只涉及有限个误差项（过去的随机扰动），它是一个**有限冲激响应（FIR）**模型，意味着它对过去的依赖是有限的。





## 自回归滑动平均模型（ARMA）



## KF

[这个推导的教程非常好](https://zhuanlan.zhihu.com/p/559191083)

已经推导完了KF的大致原理，用自己的话总结一下，KF就是针对【根据模型计算的预测值 $x_{prd}$ 】和【传感器观测的观测值 $x_{obv}$】都存在【误差或噪声】的情况下，选择一个系数K，可以把这个K理解成权重，让最终的估计值更相信预测值还是观测值【估计值 = 预测值 + 权重 x 观测误差】；而这个K值的确定，是KF滤波的另外一个原理，根据之前的（这里我还说不清楚），大概是根据最小误差原理（MSE），通过推导出估计误差（后验误差）的关于K公式，求导得到最小值。

回顾了一下之前的研究，发现使用的是阉割版的卡尔曼滤波——当时直接假设的模型是 xk= x_{k-1}，这么烂的模型也能取得不错的结果，真是不得不佩服KF的神奇；

另外，这个Q和R是不是和噪声的幅度大小之间存在什么联系？

### 增加预测模型

#### 最简单的xva模型

我记录了一系列位置的数据存于一下数组中[x0,x1....xk]，现在我希望对位置进行【建模】，下一个时刻的位置，可以根据模型和之前的数据进行预测，比如我现在使用最简单的【位置和速度信息】: x_k+1 = x_k + v_k，其中v_k = x_k - x_k-1，这个听着似乎并不是很复杂，但是我希望使用【状态空间方程state space model】对其进行建模，如何定义状态变量以及

\begin{aligned}&v_{t}=v_{t-1}+u\Delta t ---- (1)\\&p_{t}=p_{t-1}+v_{t-1}\Delta t+\frac12u(\Delta t)^2 ----- (2)\end{aligned}

\begin{bmatrix}p_t\\v_t\end{bmatrix}=\begin{bmatrix}1&\Delta t\\0&1\end{bmatrix}\begin{bmatrix}p_{t-1}\\v_{t-1}\end{bmatrix}+\begin{bmatrix}\frac{(\Delta t)^2}{2}\\\Delta t\end{bmatrix}\text{u}-----(3)

尝试了使用xv模型，但是结果不太理想，反而出现了明显的抖动

所以我现在需要确定一件事情：模型预测的准确性对最后滤波的结果会有什么影响

根据我现在对卡尔曼滤波的理解，卡尔曼针对的是系统模型预测结果存在偏差，以及测量值与真实值都存在偏差的时候，一种【最优估计】的算法。但是目前我不太清楚模型是什么，所以很难进行预测，观测也很准确的时候，遇到外来因素的干扰，导致所谓的【真实值】与我理想的值存在了偏差，我还能使用卡尔曼滤波对干扰进行修正吗？如果你觉得可以，应该怎么设计这个卡尔曼滤波，如果不可以学术上常用什么方法抗扰动？目前我想到一个方法，假如

- 

我悟了，手指末端一维上的运动，可以等效为一个小车需要在一条数轴上运动，运动路径预先设好，运动过程中因为路面不平，可能会导致小车突然减速或者加速，破坏之前的状态，

或者说末端的二维运动，就是等效一个在平面上的小车，需要按照预定的轨迹运动，速度加速度不限制，但是不能偏离轨迹，【此时的生理震颤可以等效为方向盘 或者人手人为添加了一个扰动，这个扰动会导致偏离，需要人慢慢调整回来】，调整的过程是不可避免的，而我们现在要做的事情就是【直接跳掉这个调整的过程？还需要从出现干扰开始就直接跳掉？】

如果能够增强人手的控制，在出现扰动的时候就给他快速抑制住，可以避免大幅度的偏离，这个可以通过电机的控制实现，也即【人机协作】

第二种方法，也就是现在一直在研究的，我不希望干扰人手的运动，也没有办法影响人手的运动【适用性更广，可以用于无法快速响应控制，但是还是想去除干扰的情况】



第一个方法不可行，因为我只知道有这条路（轨迹），但是轨迹不能用数据进行描述；第三个方法，实际上控制输入是未知的，只能从之前的运动数据中估计当前时刻的速度和加速度，如果知道输入命令问题反而简单了；第四个方法暂时不考虑。因此只有第二个方法或许可行。

### 自适应Q和R



## RSSA

SSA是基于无模型进行预测的，但是如果**有模型肯定更好**



SSA算法中有两个最关键的参数：步长L和能量占比r

步长越长主成分提取效果越好，但是由于“边际效应”，步长越长后面偏差越大

能量占比决定你需要保留多少成分，越少越抽象，越多越具体，1的时候就是没有分解



无论是“边界效应”，还是决策最终是否“滤波”，我们都需要通过很少的数据来预知或者判断这个“trend”会带来不需要的震颤还是正常的转向；

如果我们能判断出来：

* 如果判断是震颤，直接不相信测量值，而是选择预测值，等到检测到震颤过程结束回到正常状态
* 如果判断出来是正常转向，不做滤波处理

所以，重中之重是先收集震颤和偏转的特征，根据这些特征，在突变到来得到时候，我能不能很快的判断是哪种突变



#### current SSA

KF的问题，上面分析了，得用更牛一点的预测算法，接着之前SSA的基础，这里我们采用递归的SSA算法（RSSA），基于预先的数据提取出主运动成分，然后基于这一部分开始迭代。基于论文的原理，目前已经实现了recurrent SSA的算法

* 首先看看能否有效的进行预测：取侦察比较明显的位置(N =180, 200,268,596,770,792,1190,1380,1575,1700)，观察预测的结果
* 
* 



### Vector Forecasting

目前预测的结果存在如下问题，预测会很大程度受SSA分解的结果影响，但是SSA分解会存在边界问题（先看看怎么把这个问题解决）



在奇异谱分析（Singular Spectrum Analysis, SSA）对时间序列分解中，最后 *L* （窗口长度）个样本分解效果较差的主要原因是 **矩阵化操作导致的边界效应**



### 基于SSA的实时预测滤波算法

伪代码：

```python
# 通过训练集得到参数： height, span
# 滤波器开始执行
def judge_tremor(measure_signal, ssa_signal, threshold):
    error_M  = np.abs(measure_signal - ssa_signal)
    # 如果 max(error_M) >  threshold， 且 error_M单调递增判断为震颤出现 return 1，否则返回0
    
def judge_tremor_end(measure_signal, ssa_signal_pre):
    """
    通过观察measure_signal和预测的信号ssa_signal_pre是否相交，判断震颤在本周期中是否结束
    :param measure_signal: 
    :param ssa_signal_pre: 
    :return: 
    """
    error_M  = measure_signal - ssa_signal_pre
    # 如果error_M出现零点（离散数据，使用相邻数据是否为相反数判断零点），则 return1，否则返回0
	
# 用已有的测试集(test_signal)模拟实时获取的数据
status = 0 # 定义一个状态0为正常状态，1为震颤状态
int i = 0
M= 15
output_signal; # 最终滤除震颤后的结果
while(i<len(test_signal)): #
    tmp_data.appned(test_signal[i]) # 设定步长为M，每来M个数据进行处理一次
    if (len(tmp_data) % M): # 当tmp_data存满M个数据后开始处理数据
        if status == 0: # 上个步长为正常状态
            # 历史数据作为ssa处理的样本，有训练集数据和历史output数据构成
        	history_signal = [train_data, output_signal, tmp_data] # 这里有问题
            # 对history_signal做ssa
            ssa_abstr = ssa(history_signal)
            ssa_abstr_M = ssa_abs[-M:] # 提取ssa后最后M项并用于和tmp_data数据比较
            judge_result = judge_tremor(tmp_data, ssa_abstr_M) # 这里需要写一个函数来判断状态
            if judge_result == 0:
                status = 0; # 继续保持正常状态
            else:
                status = 1; # 检测到震颤，下一时刻状态变为tremor
            output_signal.append(ssa_abstr_M)
            # TODO : 释放清空tmp_data
        else:
            history_signal = [train_data, output_signal]
            ssa_pre_M = V_ssa_forecast(history_signal, window_length, 1, M)
            judge_result = judge_tremor_end(tmp_data, ssa_pre_M) # 判断震颤有没有结束:0为结束，1为继续震颤状态
            if judge_result == 0:
                status = 0; # 继续保持正常状态
            else:
                status = 1; # 检测到震颤，下一时刻状态变为tremor
            output_signal.append(ssa_pre_M) 
            # TODO : 释放清空tmp_data
    i++
    
    
```

目前根据上述代码的基本原理，已经实现了在没有“转向”时的实时震颤消除，也就是我已经可以实现初步的震颤识别

![image-20241216115911404](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241216115911404.png)

下一步最重要的任务是，区分震颤和转向运动

### 震颤和转弯区分

背景，我使用笔尖在平面上运动，由于【手部】的生理震颤，绘制的运动的轨迹中包含偏离预期轨迹的抖动，。为了解决这个问题，我需要实时的修复抖动的影响。目前我实现了一个算法，可以在预期轨迹没有大幅度弯曲（曲率比较小）时，通过比较观测值和预测值判定是否有震颤出现，从而直接滤除掉震颤。目前有一个问题，我的算法无法【分辨，classify】震颤和大幅度的转向运动，因为两者都会偏离我基于历史数据的预测值，另外偏转通常不是pure的，偏转中通常还携带有震颤。

因此我先一个很重要的任务是，设计一个classifier，能够【准确】的分辨震颤和转向；目前我没有什么头绪，为数不多能列出的两者的特征包括：

1. 震颤是毫无征兆的，而偏转的出现通常会先出现小幅度的偏移，就好比马路不会出现突然的急转弯，而是慢慢的转；另外转弯前速度通常是会降低的，获取能从速度中预测出来是否会转弯
2. 虽然两者在位置上都出现偏差，但是或许速度和加速度存在区别

你有什么好的办法能够帮助我区分震颤和正常的转向运动吗？对于这种分类的问题，是否可以采用ML来解决？

因为转弯通常是可以预测的，目前一个想法是，通过历史数据，来预测转弯出现的可能性，可能性越高，我就【-----】

目前我有一个想法，因为震颤通常是随机的，无规律的，无法根据历史数据来预测下一个时刻是否会有震颤出现，而转向则不同，它通常可以通过分析历史数据来推断是否会出现转弯，如果一辆车在路上行驶时，即将进入弯道时是可以通过之前的位置，速度，加速度相关参数预判出来的，你有没有什么推荐的【预测算法】可以实现我上述描述的目标任务？

我想预测时间序列中下一个“转向”的出现，转向定义为一阶导数逐渐向零靠近然后正负变换的过程，之前提到的二分类的方法过于绝对，而且很难实现，所以我现在想转变一个思路，基于【卡尔曼滤波】的启发，我想建立一个下时刻转向出现的概率{P}和预测的曲率{C_pre}与N个历史数据样本之间的模型。通过样本数据计算得到这两个参数，如果P越大说明出现转向概率越大，我们就更愿意相信预测曲率对应的数据，类似于KF中测量值与预测值之间取舍的关系。从这段话中你可以看出，目前我最重要的任务是**建立{P,C_pre}与前N个样本之间的一个【模型】**，之前有学者做过类似的研究吗？我希望你能提供一些类似的研究为我提供参考。

前面的描述可能都过于抽象，我把问题说的简单一点，对于一个半周期的正弦函数(周期为T)，从0开始，到t = T/6（有一定历史数据量，且即将出现转向t= T/4）时，能够预测出接下来会有转向出现，或者接下来会有多大的概率出现转向，下一时刻的数据能否准确预测？我认为如果仅有这些样本是不够的，相当于只有测试集没有数据集，所以，我应该怎么样才能在t = T/6是预测到t= T/4的转向呢，如果是你你会怎么做？

仅仅是前N个样本是不可能建立出来模型的，像之前说的，这是一个测试集而非数据集，因此想建立模型，需要通过很多数据集来实现。

12.17下午：建模还是很难啊，无从下手，想到一个新的办法，两个在局部最大的差别是，震颤是出现偏差后及时调整回来，而转向则是一直远离



* tremor和turn概率模型建立

  当M个数据中检测到偏移时，根据最后偏移量的大小，判断下一个M的状态， 时候，说实话我也不知道是什么，所以目前的策略就是初始tremor和turn的概率各一半（当然这样的假设是粗糙的，后续需要根据历史数据继续建模），tremor的一阶导数整体来说是递减的，尤其是S/2之后，根据这个一阶导可以建立概率模型，，





## 滑动窗口SSA

确实效果还不错，如果能够稍微修改一下，或许能够达到想要的效果；之前纯采用采集的数据进行ssa分析，根据卡尔曼迭代的原理，采用估计值进行ssa分析可能更优一点

目前，我的算法中有几个比较重要的参数

1. 外层滑动窗口长度：理论分析来说，这窗口越长，涉及的历史点就越多，对观测的数据就越不敏感，相当于L_out自身就可以调节观测值和测量值的权重。 这也可以反映了一点，**L-out越小，越相信测量值**，滤波效果就越差，所有这是一个需要动态调整的值
2. 内层窗口长度，从原理上来说最终轨迹矩阵的维度为 L_in x (L-out - L_in + 1)，所以L_in 在取a和 L_out -a 时结果是一样的，但是似乎L_out - a的计算都更低；L_in 的长度越靠近 L_out/2，抽象程度越高，越远离抽象程度越低
3. 能量占比这个东西最好理解了，越小越抽象，但是有下限的
4. 缓存窗口数据长度M，这个数据越大，意味着更新的步长越长，计算复杂度会降低，但是M不能太长否则会有延迟；从数据分析上来说，M越大，更准确的来说M/L_out的比值越大，观测值所占的比值就越多，越相信测量值

目前【调试好参数的情况下】，大体能够实现震颤过滤如下图，但是存在如下一些问题

![image-20241223101005366](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241223101005366.png)

* 老问题，ssa去除震颤的核心原理就是利用主成分分析提取主要成分，增强鲁棒性，换句话说就是对数据不敏感，所以对于转弯这类的操作，不应该不敏感
* 对于突发的状况，应该有一套规避机制

对于第一个问题，之前尝试的概率模型或许是有用的（在转弯前明显会出现）

记录每个步长的朝向u，通过u的变换可以大致将运动分为三个阶段：

* 直线运动阶段L
* 直线-曲线过渡阶段L-C
* 曲线运动阶段C

重点是如何通过u判断阶段，我的办法是构建一个模型

* 首先如果从直线状态开始，历史数据会有一个大致的朝向u_0，只要在 只要在u_0的±$\theta_0$范围内波动都可以接受，这个$\theta_0$也可以通过【数据统计】得出；
* 一旦偏离这个容许范围，判定进入L-C阶段，该阶段内预测为转弯的概率P与$\Delta u$满足一个对数关系，也即偏离越大，越可能是弯曲
* 当大到一定的程度$\theta_1$ 时，基本可以判定就是Curve了

（说不定真的可以使用sigmoid函数来做这个概率映射）

通常u的改变跨度不会超过$\theta_1$ ，如果直接跳过过渡阶段进入曲线阶段可以判定为

$$
p_c = \frac{1}{1 + e^{-a (\Delta \theta - b)}}
$$

其中：
$$
a = \frac{2 \cdot \text{cutoff}_p}{\theta_2 - \theta_0}, \quad b = \theta_1 + \theta_0
$$
$$
\theta_0 = \theta_{\text{ref}} \cdot \left( 1 - \cos\left( \frac{\pi}{8} \right) \right), \quad \theta_2 = \theta_{\text{ref}} \cdot 0.5, \quad \theta_1 = \frac{\theta_0 + \theta_2}{2}
$$
$$
\Delta \theta = \left| \theta_k - \theta_{\text{ref}} \right|
$$

有了这个概率p（目前是curve的概率）以后，ssa的结果可以视作预测值，最后估计值可以做一个简单的KF处理
$$
V_e = V_{ssa} * (1-p) + V_{meas} * p
$$
这样也不太好，如果p=100%，那岂不是没有滤波效果了；而且KF中最有估计的精髓没有掌握到



--------------

创建了SSA_filter_with_P的py文件，用于调试，目前存在以下问题

1. 初始化时（目前一定要以直线运动开始），需要设计一个初始处理器获得初始角度，作为参考值
2. 如何确定从直线运动到过渡状态的阈值theta_0 和 从过渡状态到曲线运动theta_1，以及从曲线回到直线状态的阈值theta_3
3. 应该加一个从曲线回到直线的过渡状态
4. 每种状态应该有一个独特的运动模型，可以预测，对于偏离的值，那就是tremor



#### 阈值确定



theta
