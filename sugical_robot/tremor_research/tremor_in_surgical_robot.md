# 手术机器人消抖

## 研究背景

what：什么是生理性震颤？

**生理性震颤**是正常人群中普遍存在的一种震颤类型，是身体部位快速来回运动的表现。

why：为什么会产生这个震颤？

医生怎么说？工程师怎么说？

* 临床定义：

  这种震颤由两种不同的振荡——**机械反射和中枢神经源性振荡**——叠加在不规则的肌肉力量波动和肢体位移的背景上。（但是具体是什么原因医生也没有搞明白）

  1. **机械反射振荡**：大多数正常受试者的主要频率成分。
     
     - 主要由身体的惯性和弹性属性决定，表现为阻尼振荡，响应于诸如肌肉单位放电不规则性和心脏收缩期血液喷射等脉冲扰动。
     - 机械反射的频率与关节的刚度（K）和惯性（I）相关，频率公式为 *w*=*K*/*I*。例如，肘部震颤的频率为 3-5 Hz，手腕震颤为 7-10 Hz，指关节震颤为 12-30 Hz。
     
  2. **中枢神经源性振荡**：(这里我其实还没有看懂)
     
     - 与运动单位活动的调节相关，这种振荡不仅仅是对感觉反馈的被动反应，而是主动驱动肢体振荡的节律性运动单位活动。
     - 中枢神经源性震颤的频率通常在 8-12 Hz 范围内，不受惯性或刚度的影响，也独立于拉伸反射的长度。这种振荡被认为源于中枢神经系统中的振荡神经网络。
     
  3. **反射机制**：
  
     - **振荡反馈**：由中枢神经系统的反射回路引起，当肌肉收缩或伸展时，肌肉梭的敏感性上升，会产生周期性反馈，增加肌肉活动的节律性。
     - **反射增益**：反射增益和传导时间的适当配合会导致反射激活振荡产生震颤。
  
     





如果没有人为的干涉，手术机器人在工作时末端会存在较为严重的震颤情况，这个是毋庸置疑，震颤主要来源于以下几个方面：

* 生理震颤是一种正常的、低频的肌肉微抖动，通常在成人中频率约为每秒10次。它是由多个突触耦合的神经系统与外部效应器的生物力学、物理和电特性之间的动态相互作用引起的。[PHYSIOLOGICAL TREMOR](https://scholar.google.com/scholar?hl=zh-CN&as_sdt=0%2C5&q=PHYSIOLOGICAL+TREMOR&btnG=) ，Tremor From Pathogenesis to Treatment。在长时间的劳作之后，生理震颤会加剧，疲劳引起的手部震颤 (FIT) 是一种不可避免的现象，它极大地限制了长时间腹腔镜手术的手术操作的准确性。肌肉疲劳引起的手部震颤具有高度非线性和非平稳特性，需要不同于传统滤波器的滤波策略。
* 关节编码器的数据有噪声，但是这个似乎非常的不明显这个看看用卡尔曼滤波能不能很好的解决。
* 呼吸带来的震颤虽然频率小，但是幅度远大于生理震颤，因此对呼吸的抖动进行抑制也是一个值得研究的内容
* 另外运动是不可能保持很直，尤其是在主从遥控的背景下（是否可以通过模式识别，识别出操作者的意图，进行一定的辅助）

但是这个噪声很小，只要设备够好，基本上不会出现很大的噪声：

![](static_end.png)



![](static_each_angle.png)



但是，还是希望能够将这样一个震颤在3D条件下可视化出来。因此需要做一些工程上的事情：

1. 使用电脑接受CAN发来的数据，并存在txt文件中
2. python/matlab读取txt文件，然后根据之前的函数绘制末端点+箭头改变情况



### 消抖方法研究-别人是怎么做的：

* 低通滤波：手部是高频信号，而期望的输入信号是低频信号

  缺点：会使得信号存在延迟/低通滤波需要设置固定的频率阈值，导致了滤波结果损失了 部分信息，低通滤波仅能实现精度要求不高的震颤滤除

* 零相位滤波：无法应用于实时系统（不太懂零相位滤波的原理，只知道可以调相位）

* 傅里叶线性组合器：先对震颤信号进行建模，然后将震颤信号反向叠加到控制信号（有点像AirPods工作原理）

* 加权傅里叶线性组合器L可以估计任意近似周期的震颤信号——者手部生理震颤信号的频率、幅 值、相位进行估计建模，在此基础上生成一个频率和相位与震颤信号相同，幅 值与震颤信号相反的补偿信号来滤除震颤信号

* 卡尔曼滤波：利用惯 性测量单元测量手持显微外科仪器角速度，通过分析传感器噪声分量得到噪声 协方差

* 基于AR模型滤波：自适应滤波策略（这个看着就比较花哨比较难了）

* 自适应多步震颤预测策略：有效改进**传统滤波相位延迟问题**

* 基于EMD（多模态分解）的滤波方法



### 残余振动抑制

* ”机械臂关节摩擦引起的关节柔性对摩擦 进行建模“（逐渐抽象看不懂），**基于变结构控制设计的多状态反演控制方法** ；单关节摩擦建模（<font color = red>又为什么都是对摩擦进行建模呢</font>）
* 柔性环节简化，实现反馈线性化







## 带限多重傅立叶

带限多重傅立叶，就是实用多个余弦函数对输入信号进行模拟，所谓带限即使设定一个组合余弦函数的的频率范围，并且讲频率均匀离散的分布到n，需要优化确定的参数就是每个频率函数对应的权重，可以得到一个输入模拟信号和输出合成信号的线性方程，文章使用了以下方法求解权重：

1. 最小均方根算法：一种滤波中常用的算法
2. 卡尔曼迭代算法，利用卡尔曼滤波的原理，构建权重相关的状态转移方程，即可使用卡尔曼算法进行迭代
3. 递推最小二乘算法(RLS)，原理和最小均方根基本相似，只是权重和递归增益的更新数学模型较为复杂
4. 



### 参数辨识

常见的方法有实验 辨识法和动力学建模计算法。 

作者认为：建模 精度限制，存在一定的误差。 

实验法：时域辨识和频域辨识

作者使用





### 作者的主从映射

因为不是直觉映射，所以映射关系绕了很多弯子，目标还是建立主端（输入端）的坐标变换和从端（输出端）之间的变换关系，之前我建立的映射关系就是：

* 位置缩放：提出一个根据主从端工作空间比例计算缩放比例的方法，比较科学
* 姿态相同

作者也是一样，不过作者一共转了4次，比较复杂







最小均方根（Least Mean Square，简称LMS）算法是一种自适应滤波器算法，用于调整滤波器的权重以最小化其输出与期望输出之间的均方误差。这个算法的主要应用领域包括信号处理、通信系统、自适应滤波、机器学习等。

以下是LMS算法的核心原理和步骤：

1. **基本原理**：LMS算法的核心思想是通过不断地调整滤波器的权重，使其输出逼近期望输出，从而最小化均方误差。这是一种迭代过程，通过不断观察实际输出和期望输出之间的误差来更新权重，以逐渐收敛到最优权重值。

2. **滤波器模型**：LMS算法通常使用一个线性滤波器模型。给定输入信号x(n)和滤波器权重向量w(n)，滤波器的输出y(n)计算如下：
  
   ```
   y(n) = w^T(n) * x(n)
   ```

   其中，w^T(n)表示权重向量的转置，* 表示向量内积。

3. **误差计算**：算法首先计算实际输出与期望输出之间的误差e(n)：
  
   ```
   e(n) = d(n) - y(n)
   ```

   其中，d(n)表示期望输出，y(n)表示实际输出。

4. **权重更新**：LMS算法的关键步骤是根据误差e(n)来更新滤波器的权重。更新的规则通常如下所示：

   ```
   w(n+1) = w(n) + μ * e(n) * x(n)
   ```

   其中，w(n+1)表示新的权重向量，w(n)表示旧的权重向量，μ（mu）是学习率，它决定了权重更新的步长。

5. **迭代过程**：LMS算法通过不断重复上述步骤，即计算误差、更新权重，来逐渐调整滤波器的权重，使输出逼近期望输出。这是一个自适应过程，通常需要多次迭代才能达到最佳权重值。

6. **收敛性**：LMS算法通常在某个误差阈值下或者在连续的迭代中停止。算法的性能和收敛速度与学习率μ的选择、滤波器的初始权重和输入信号的统计特性等因素有关。

LMS算法的一个重要应用是自适应滤波，用于去除信号中的噪声或调整系统参数以适应不断变化的环境。它也在机器学习中的在线学习和梯度下降算法中有广泛应用。通过逐渐优化权重，LMS算法能够有效地逼近最佳解决方案，从而在多种领域中发挥作用。





递推最小二乘算法（Recursive Least Squares，简称RLS）是一种自适应滤波器算法，用于估计滤波器的权重，以最小化均方误差。与LMS（Least Mean Square）算法不同，RLS算法具有递推性质，能够随着新的数据点的到来，连续地更新权重，而无需重新处理历史数据。这使得RLS在需要实时处理数据或在计算资源有限的环境中特别有用。

以下是RLS算法的核心原理和步骤：

1. **基本原理**：RLS算法的核心思想是通过递归地更新权重向量，以逼近实际输出和期望输出之间的均方误差最小化。算法随着新的数据点的到来，动态地更新权重向量。

2. **滤波器模型**：与LMS算法一样，RLS算法通常使用线性滤波器模型。给定输入信号x(n)和权重向量w(n)，滤波器的输出y(n)计算如下：
  
   ```
   y(n) = w^T(n) * x(n)
   ```

   其中，w^T(n)表示权重向量的转置，* 表示向量内积。

3. **误差计算**：与LMS类似，RLS算法首先计算实际输出与期望输出之间的误差e(n)：
  
   ```
   e(n) = d(n) - y(n)
   ```

   其中，d(n)表示期望输出，y(n)表示实际输出。

4. **权重更新**：RLS算法的关键是递归地更新权重向量。权重向量的更新规则如下：

   ```
   w(n+1) = w(n) + K(n) * e(n) * P(n) * x(n)
   ```

   其中，w(n+1)表示新的权重向量，w(n)表示旧的权重向量，K(n)是递归增益，P(n)是协方差矩阵的递归更新，它们都是关于历史数据的函数。

5. **递归增益更新**：递归增益K(n)的更新是RLS算法的关键。K(n)的更新规则通常如下：

   ```
   K(n) = P(n) * x(n) / (λ + x^T(n) * P(n) * x(n))
   ```

   其中，λ是一个小正数，用于避免除以零的情况。x(n)表示输入信号，P(n)表示协方差矩阵，它也是递归更新的。

6. **协方差矩阵的递归更新**：协方差矩阵P(n)也是递归更新的，通常使用以下规则：

   ```
   P(n+1) = 1/λ * [P(n) - P(n) * x(n) * x^T(n) * P(n) / (λ + x^T(n) * P(n) * x(n))]
   ```

   其中，λ是一个小正数。

RLS算法的主要优点是其快速收敛性和递归性质，使其适用于需要实时数据处理和动态权重更新的应用。然而，与LMS算法相比，RLS算法的计算复杂度较高，因此在计算资源有限的环境中可能不太适用。 RLSS算法在信号处理、自适应滤波、通信系统等领域有广泛应用。















## 开始实践

* 工具可以实时储存，这个太棒了

  存在.csv 文件中，通过pandas库获取到CAN数据帧，存储于<class 'pandas.core.series.Series'>数据结构中，不过有一些多余的信息需要删减

  并将每6帧数据存储到一个 6x8 的数组中

* 转码，将读取到的16进制CAN数据帧 转为可读的 十进制float数据

  成功转码，先将所有float都存到一个float[] decoded_floats 中，然后需要稍微处理一下，得到左手和右手的数据，每行都是5个

* 通过正向运动学，得到末端的信息e

  搞定了，见FK.py 文件

* 将这些信息全部存储下来绘制

  搞定，见 plot_traj.py文件

* 采集数据，需要设计几个动作，看看别人是什么做的

* 对比滤波的效果



### 数据采集

在论文[Empirical Mode Decomposition-based filtering for fatigue induced hand tremor in laparoscopic manipulation](https://www.sciencedirect.com/science/article/pii/S1746809416301264)中，作者设计了下面几个任务：

1. 在矢状面上进行动态线追踪：受试者 沿垂直平面上绘制的 25 厘米长线移动，这是腹腔镜常见的移动长度
2. 静态握持腹腔镜工具：要求所有受试者将工具握在给定点而不做任何移动